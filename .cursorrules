# Cursor Rules for gemini4s

# Project Structure Guidelines
- Source code should be organized in the src/main/scala/gemini4s directory
- Test code should be in the src/test/scala/gemini4s directory
- Follow the tagless final pattern for all core abstractions
- Use ZIO for effects and resource management

# Project Layers
- Foundation Layer: error types and core models
- Core API Layer: algebra definitions and HTTP client
- Implementation Layer: ZIO interpreter
- Documentation Layer: examples and guides

# Development Workflow
- Start with foundation layer tasks first
- Core API layer tasks can be worked on in parallel once foundation is ready
- Implementation layer depends on both foundation and core API layers
- Documentation should be updated incrementally but finalized last
- Each layer must maintain 90% test coverage

# Coding Standards
- Use meaningful type parameters (e.g., F[_] for effect type)
- All public APIs must be documented with ScalaDoc
- Error handling should use custom ADTs in the error channel
- Prefer immutable data structures
- Use ZIO's built-in testing framework for all tests

# File Organization
- One primary trait/type class per file
- Implementation modules should be in separate files
- Keep files focused and small (< 300 lines)
- Group related functionality in packages

# Git Flow Guidelines
- Main branch is protected and requires PR review
- Feature branches should be named: feature/[issue-number]-short-description
- Bug fix branches should be named: fix/[issue-number]-short-description
- Release branches should be named: release/v[version]
- All commits should reference issue numbers: "#123: Add feature X"
- Squash commits before merging to main
- Delete branches after successful merge

# Project Board Usage
- All development work must be tracked in the project board
- New features/bugs start in "To Do"
- Move cards to "In Progress" when work begins
- Use "Review" column for PR review phase
- Only move to "Done" after tests pass and PR is merged
- Link commits and PRs to relevant project cards
- Update card status when transitioning between columns
- Check task dependencies before starting new work

# Dependencies Management
- Check issue dependencies before starting work
- Don't start tasks if dependencies aren't complete
- Mark blocked tasks in project board
- Update dependent tasks when completing work

# Testing Requirements
- All public APIs must have test coverage
- Use property-based testing where appropriate
- Mock external services in tests
- Include both unit and integration tests
- Maintain minimum 90% code coverage with scoverage
- Run full test suite before submitting PR

# Error Handling
- Define specific error types for each failure case
- Use ZIO error channel for error propagation
- Provide meaningful error messages
- Handle rate limiting and API quotas gracefully

# Performance Considerations
- Use streaming for large responses
- Implement proper resource cleanup
- Consider backpressure in streaming operations
- Cache responses where appropriate

# Documentation
- Keep README.md up to date
- Document all type class instances
- Include examples in ScalaDoc
- Maintain CHANGELOG.md
- Document dependencies between components